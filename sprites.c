/*
 *  WÃ¼rgertime - An hommage to Burger Time
 *
 *  Copyright (C) 2012 by Jan Kandziora <jjj@gmx.de>
 *  licensed under the GNU GPL v3 or later
 *
 *  see https://github.com/janka/wuergertime
 *
 * ---------------------------------------------------
 *
 *  sprites.c - sprite tile organisation and aggregates.
 */


#include <avr/io.h> /* for uint8_t */
#include <avr/pgmspace.h> /* for PROGMEM */
#include <uzebox.h>


/* Local includes. */
#include "tiles.h"
#include "data/sprites.inc"


/* Actual sprite tile data, generated by pcxtotiles.tcl tool */
#include "data/sprites0.inc"


/* Megasprite animations. */
#define SPRITE_ANIMATION_COOK_SIDE_MAX 4
const uint8_t SpriteAnimationCookSide[SPRITE_ANIMATION_COOK_SIDE_MAX][4] PROGMEM = {
	TILES_BLOCK(TILES2_COOK_SIDE_ANIMATE0),
	TILES_BLOCK(TILES2_COOK_SIDE_ANIMATE1),
	TILES_BLOCK(TILES2_COOK_SIDE_ANIMATE2),
	TILES_BLOCK(TILES2_COOK_SIDE_ANIMATE3),
};


#define SPRITE_ANIMATION_COOK_LADDER_MAX 8
const uint8_t SpriteAnimationCookLadder[SPRITE_ANIMATION_COOK_LADDER_MAX][4] PROGMEM = {
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE0),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE1),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE2),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE3),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE4),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE5),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE6),
	TILES_BLOCK(TILES2_COOK_LADDER_ANIMATE7),
};


/* Megasprite slots. */
struct {
	uint8_t x, y;
	uint8_t flags;
} GameSpriteSlots[SPRITE_SLOTS_MAX];


/* Reset sprite slots. */
void resetSpriteSlots(void) {
	uint8_t i;

	for(i=0;i<SPRITE_SLOTS_MAX;i++)
		GameSpriteSlots[i].flags=SPRITE_FLAGS_FREE_SLOT;
}


/* Occupy a sprite slot. */
uint8_t occupySpriteSlot(void) {
	uint8_t i;
	
	/* Get a free sprite slot. */
	for(i=0;i<SPRITE_SLOTS_MAX;i++)
		if (GameSpriteSlots[i].flags == SPRITE_FLAGS_FREE_SLOT) break;
	
	/* Return free slot number. */
	return i;
}


/* Free a sprite slot. */
void freeSpriteSlot(uint8_t slot) {
	uint8_t i;

	/* Skip if the slot is free already. */ 
	if (GameSpriteSlots[slot].flags == SPRITE_FLAGS_FREE_SLOT) return;

	/* Unmap kernel sprites for that slot. */
	for(i=0;i<4;i++)
		sprites[slot*4+i].y=0xf0; /* invalid coordinate */

	/* Free the slot. */
	GameSpriteSlots[slot].flags=SPRITE_FLAGS_FREE_SLOT;
}


/* Place a sprite somewhere. */
void placeSprite(uint8_t slot, uint8_t x, uint8_t y, uint8_t flags) {
	uint8_t tile,i;
	const uint8_t *p;

	/* Remember position and flags. */
	GameSpriteSlots[slot].x=x;
	GameSpriteSlots[slot].y=y;
	GameSpriteSlots[slot].flags=flags;

	/* Setup kernel sprites according to flags. */
	switch (flags & (SPRITE_FLAGS_TYPE_MASK|SPRITE_FLAGS_DIRECTION_MASK)) {
		case SPRITE_FLAGS_TYPE_SCORE:
			break;
		case SPRITE_FLAGS_TYPE_COOK|SPRITE_FLAGS_DIRECTION_LEFT:
		case SPRITE_FLAGS_TYPE_COOK|SPRITE_FLAGS_DIRECTION_RIGHT:
			/* Get address of first tile number for given animation step. */
			p=&SpriteAnimationCookSide[GameSpriteSlots[slot].flags & SPRITE_FLAGS_ANIMATION_MASK][0];
			i=slot*4;

			/* Place tiles, honor mirroring. */
			tile=pgm_read_byte(p);
			sprites[i].tileIndex=tile & (~SPRITE_MIRROR);
			sprites[i].flags=(tile & SPRITE_MIRROR)^(flags & SPRITE_FLAGS_DIRECTION_RIGHT)?SPRITE_FLIP_X:0;
			sprites[i].x=x;
			sprites[i].y=y;
			p++;
			i++;
			x+=8;

			tile=pgm_read_byte(p);
			sprites[i].tileIndex=tile & (~SPRITE_MIRROR);
			sprites[i].flags=(tile & SPRITE_MIRROR)^(flags & SPRITE_FLAGS_DIRECTION_RIGHT)?SPRITE_FLIP_X:0;
			sprites[i].x=x;
			sprites[i].y=y;
			p++;
			i++;
			x-=8;
			y+=8;

			tile=pgm_read_byte(p);
			sprites[i].tileIndex=tile & (~SPRITE_MIRROR);
			sprites[i].flags=(tile & SPRITE_MIRROR)^(flags & SPRITE_FLAGS_DIRECTION_RIGHT)?SPRITE_FLIP_X:0;
			sprites[i].x=x;
			sprites[i].y=y;
			p++;
			i++;
			x+=8;

			tile=pgm_read_byte(p);
			sprites[i].tileIndex=tile & (~SPRITE_MIRROR);
			sprites[i].flags=(tile & SPRITE_MIRROR)^(flags & SPRITE_FLAGS_DIRECTION_RIGHT)?SPRITE_FLIP_X:0;
			sprites[i].x=x;
			sprites[i].y=y;

			break;
		case SPRITE_FLAGS_TYPE_COOK|SPRITE_FLAGS_DIRECTION_LADDER:
			break;
		case SPRITE_FLAGS_TYPE_COOK|SPRITE_FLAGS_DIRECTION_FACING:
			break;
		case SPRITE_FLAGS_TYPE_EGGHEAD:
			break;
		case SPRITE_FLAGS_TYPE_SAUSAGEMAN:
			break;
		case SPRITE_FLAGS_TYPE_MRMUSTARD:
			break;
	}
}


/* Move/Animate a sprite. */
void moveSprite(uint8_t slot, int8_t x, uint8_t y) {
}


